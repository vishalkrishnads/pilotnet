from utils.screen import clear, warn, message, error
from utils.collect import Collector
from utils.piloterror import PilotError
from src.data import Data, PilotData
from src.model import PilotNet
import carla, random, time, datetime, os

# you could totally enable a feature by which a model trained in a session can be used as fallback if there are no trained models available
# but for this, PilotNet would have to compile and store a model in memory from the start, which may hinder performance of other utilities
# you can do this by uncommenting this line and commenting any lines starting with PilotNet() from this file
# pilotnet = PilotNet(160, 120)

class Menu():

    @staticmethod
    def run_1():
        'Train using generated data'
        data = Data()
        message('Data collection finished')

        # this is some nasty code here, will have to be cleaned up
        message('How much epochs do you wanna train the model? The default is 30.')
        epochs = int(input('Enter epochs >> ') or 30)
        message('How much steps do you wanna run per epoch? The default is 10.')
        steps = int(input('Enter steps >> ') or 10)
        message('How many steps do you wanna run for validation? The default is 10.')
        steps_val = int(input('Enter steps >> ') or 10)
        message('Enter the batch size to use for training. The default is 64')
        batch_size = int(input('Enter size >> ') or 64)
        message('Give a filename for the model. Skip to use an autogenerated name.')
        name = input('Enter a name >> ') or f"{epochs}epochs_{steps}perepoch_{datetime.datetime.now().strftime('@%Y-%m-%d-%H:%M')}"
        message('Enter the frame dimensions of images. Note that higher sizes consume higher memory')
        width = input('Enter width (default 160) >> ') or 160
        height = input('Enter height (default 120) >> ') or 120

        clear()
        try:
            message(f'Starting tensorflow model with {width}x{height} images')
            pilotnet = PilotNet(width, height)
        except:
            raise PilotError('Oops, that didnt work. System might be out of memory. Try again with smaller dimensions.')
        clear()
        message('Starting training')
        try:
            pilotnet.train(name, data, epochs, steps, steps_val, batch_size)
        except:
            raise PilotError('Some unexpected error occured during training. Please try again.')

    @staticmethod
    def run_2():
        'Generate new data'
        message('Connecting to CARLA world')
        client = carla.Client('localhost', 2000)
        try:
            world = client.get_world()
            message('Connected to CARLA server')
        except:
            try:
                warn('There seems to be a problem with your CARLA server. Retrying with WSL address...')
                client = carla.Client('172.17.128.1', 2000) # the host IP can be found with $(hostname).local from WSL
                world = client.get_world()
                message('Connected to CARLA server')
            except:
                raise PilotError('Connection to CARLA simulator failed. Check your CARLA installation, confirm simulator is running on port 2000.\nIf in WSL, refer to the troubleshooting guide for tips.')
        time = int(input('Enter the time you need the generator to run for (in minutes) >> '))
        clear()
        collector = Collector(world, time)

    @staticmethod
    def run_3():
        'Predict on a single video frame'
        i = 0
        models = []
        message('Fetching list of saved models...')
        with os.scandir('models/') as saved_models:
            for model in saved_models:
                print(f'{i+1}. {model.name}')
                models.append(model.name)
                i+=1
        if len(models) <= 0:
            warn('There are no saved models. Using previously trained models from the same session is totally possible but disabled due to performance issues.')
            message('Simply train a model from the menu and try again...')
        else:
            choice = int(input('Choose the model you wanna use (1) >> ') or 0)
            while choice not in models:
                try:
                    choice = models[choice-1]
                    message(f'{choice} selected.')
                except:
                    error('Wrong choice. Try again...')
            model = choice
            path = input('Enter path relative to this directory >> ')
            try:
                frame = PilotData(isTraining=False, path_to=path)
            except:
                raise PilotError("That didn't work. The path you entered must be wrong. Start again...")
            predictions = PilotNet(160, 120, predict=True).predict(frame, given_model=model)
            clear()
            message('Predictions are...')
            message(f'Steering angle: {predictions[0][0][0]}')
            message(f'Throttle: {predictions[1][0][0]}')
            message(f'Brake: {predictions[2][0][0]}')
            input('Press [ENTER] to continue...')
            
    @staticmethod
    def run_4():
        'Predict on live video feed'
        raise PilotError("Um sorry bruh. Live video prediction isn't available yet. I'm working on it keep an eye here.")

    @staticmethod
    def run_5():
        'Wrap up. I wanna quit.'
        message('Hope you enjoyed PilotNet. Report any issues on GitHub..')

    @staticmethod
    def execute(user_input):
        task_name = f'run_{user_input}'
        try:
            menu = getattr(Menu, task_name)
            clear()
        except AttributeError:
            shitquotes = [
                'Uh huh, where are your eyes at? Open sesame...',
                "Now what's up with that?",
                'Um sorry not on this menu...',
                "Sorry I couldn't read your mind. Come again?",
                "Good choice, congrats. Now try again."]
            raise PilotError(random.choice(shitquotes))
        else:
            menu()
    
    @staticmethod
    def generate_instructions():
        do_methods = [m for m in dir(Menu) if m.startswith('run_')]
        menu_string = "\n".join(
            [f'{method[-1]}.  {getattr(Menu, method).__doc__}' for method in do_methods])
        print(menu_string)
    
    @staticmethod
    def run():
        user_input = 0
        while(user_input != 5):
            clear()
            Menu.generate_instructions()
            user_input = int(input("Enter your choice >> "))
            try:
                Menu.execute(user_input)
            except PilotError:
                input('Press [ENTER] to continue')
            except KeyboardInterrupt:
                message('Hope you enjoyed using PilotNet. Report any issues on GitHub.')

def main():
    Menu.run()

if __name__ == '__main__':
    main()